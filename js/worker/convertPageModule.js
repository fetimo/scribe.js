// Functions from other modules
// The following functions are copy/pasted from other files due to Node.js not supporting import statements within workers.
// They should be replaced with import statements once support for imports in workers is universal or an alternative is found.
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#browser_compatibility

// const ocr = await import('../objects/ocrObjects.js');

import ocr from '../objects/ocrObjects.js';

import { getRandomAlphanum, quantile, mean50 } from '../miscUtils.js';

import { FontMetricsRawFamily } from '../objects/fontMetricsObjects.js';

import { LayoutBox } from '../objects/layoutObjects.js';

import { unionFontMetricsFont, determineSansSerif } from '../fontStatistics.js';

// If enabled, raw strings are saved in OCR objects for debugging purposes.
const debugMode = true;

/**
 * Unescapes XML in a string
 * @param {String} string
 * @return {String}
 */
function unescapeXml(string) {
  return string.replace(/&amp;/, '&')
    .replace(/&quot;/g, '"')
    .replace(/&apos;/g, "'")
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&gt;/g, '>')
    .replace(/&#39;/g, "'")
    .replace(/&#34;/g, '"')
    .replace(/&#x2014;/g, '—')
    .replace(/&#x8211;/g, '–')
    .replace(/&#x201c;/g, '“')
    .replace(/&#x201d;/g, '”')
    .replace(/&#x2018;/g, '‘')
    .replace(/&#x2019;/g, '’')
    .replace(/&#xa7;/g, '§');
}

/**
 * Rounds a number to six decimal places.
 * @param {number} x - The number to be rounded.
 * @returns {number} The rounded number.
 */
function round6(x) {
  return (Math.round(x * 1e6) / 1e6);
}

// Includes all capital letters except for "J" and "Q"
const ascCharArr = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L', 'M', 'N', 'O', 'P', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
  'b', 'd', 'h', 'k', 'l', 't', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
const xCharArr = ['a', 'c', 'e', 'm', 'n', 'o', 'r', 's', 'u', 'v', 'w', 'x', 'z'];

/**
 * @param {Object} params
 * @param {string} params.ocrStr
 * @param {number} params.n
 * @param {?dims} params.pageDims
 * @param {number} params.rotateAngle - The angle that the input image is rotated prior to recognition.
 *    This is used to transform OCR coordinates back to the original coordinate space after recognizing a rotated intermediate image.
 * @param {boolean} params.keepItalic - If true, italic tags (`<em>`) are honored.  This is false by default,
 *    as vanilla Tesseract does not recognize italic text in a way that is reliable.
 *    This is fixed for Legacy recognition in the included custom build of Tesseract.
 */
export async function convertPageHocr({
  ocrStr, n, pageDims = null, rotateAngle = 0, keepItalic = false,
}) {
  rotateAngle = rotateAngle || 0;
  /** @type {Object.<string, FontMetricsRawFamily>} */
  const fontMetricsRawPage = {};

  const angleRisePage = [];
  const lineLeft = [];
  const lineTop = [];

  // If page dimensions are not provided as an argument, we assume that the entire image is being recognized
  // (so the width/height of the image bounding box is the same as the width/height of the image).
  if (!pageDims) {
    const pageElement = ocrStr.match(/<div class=["']ocr_page["'][^>]+/i);
    if (pageElement != null) {
      const pageDimsMatch = pageElement[0].match(/bbox \d+ \d+ (\d+) (\d+)/i);
      if (pageDimsMatch != null) {
        pageDims = { height: parseInt(pageDimsMatch[2]), width: parseInt(pageDimsMatch[1]) };
      }
    }
  }

  const pageObj = new ocr.OcrPage(n, pageDims);

  // Test whether character-level data (class="ocrx_cinfo" in Tesseract) is present.
  const charMode = !!/ocrx_cinfo/.test(ocrStr);

  // Test whether cuts are present.
  // This will be the case for users re-importing HOCR generated by the site.
  // const cutsMode = /\<span[^\>]*cuts/i.test(ocrStr) ? true : false;

  // The JavaScript regex engine does not support matching start/end tags (some other engines do), so the end of words and lines are detected
  // through a hard-coded number of </span> end tags.  The only difference charMode should make on the expressions below is the number of
  // consecutive </span> tags required.
  let lineRegex;
  if (charMode) {
    // lineRegex = new RegExp(/<span class\=[\"\']ocr_line[\s\S]+?(?:\<\/span\>\s*){3}/, "ig");
    lineRegex = /<span class=["']ocr_line[\s\S]+?(?:<\/span>\s*)(?:<\/em>\s*)?(?:<\/span>\s*){2}/ig;
  } else {
    lineRegex = /<span class=["']ocr_line[\s\S]+?(?:<\/span>\s*){2}/ig;
  }

  const wordRegexCharLevel = /<span class=["']ocrx_word[\s\S]+?(?:<\/span>\s*)(?:<\/em>\s*)?(?:<\/span>\s*){1}/ig;
  const wordRegex = /<span class=["']ocrx_word[\s\S]+?(?:<\/span>\s*)/ig;

  const charRegex = /<span class=["']ocrx_cinfo["'] title='([^'"]+)["']>([^<]*)<\/span>/ig;
  const wordElementRegex = /<span class=["']ocrx_word[^>]+>/i;
  // const wordTitleRegex = new RegExp(/(?<=title\=[\"\'])[^\"\']+/);

  // Remove all bold/italics tags.  These complicate the syntax and are unfortunately virtually always wrong anyway (coming from Tesseract).
  ocrStr = ocrStr.replaceAll(/<\/?strong>/ig, '');

  // The custom built-in Tesseract build should reliably identify italics (for Legacy only)
  if (!keepItalic) {
    ocrStr = ocrStr.replaceAll(/<\/?em>/ig, '');
  }

  // Delete namespace to simplify xpath
  ocrStr = ocrStr.replace(/<html[^>]*>/i, '<html>');

  // Replace various classes with "ocr_line" class for simplicity
  // At least in Tesseract, these elements are not identified accurately or consistently enough to warrent different treatment.
  ocrStr = ocrStr.replace(/(class=')ocr_caption/ig, '$1ocr_line');
  ocrStr = ocrStr.replace(/(class=')ocr_textfloat/ig, '$1ocr_line');
  ocrStr = ocrStr.replace(/(class=')ocr_header/ig, '$1ocr_line');

  /**
   * @param {string} match
   */
  function convertLine(match) {
    const titleStrLine = match.match(/title=['"]([^'"]+)/)?.[1];
    if (!titleStrLine) return '';

    const linebox = [...titleStrLine.matchAll(/bbox(?:es)?(\s+\d+)(\s+\d+)?(\s+\d+)?(\s+\d+)?/g)][0].slice(1, 5).map((x) => parseInt(x));

    // The baseline can be missing in the case of vertical text (textangle present instead)
    const baselineMatch = [...titleStrLine.matchAll(/baseline(\s+[\d.-]+)(\s+[\d.-]+)/g)][0];

    if (!baselineMatch) return '';

    const baseline = baselineMatch.slice(1, 5).map((x) => parseFloat(x));

    // Only calculate baselines from lines 200px+.
    // This avoids short "lines" (e.g. page numbers) that often report wild values.
    if ((linebox[2] - linebox[0]) >= 200) {
      angleRisePage.push(baseline[0]);
      lineLeft.push(linebox[0]);
      lineTop.push(linebox[1]);
    }

    // Line font size metrics as reported by Tesseract.
    // As these are frequently not correct (as Tesseract calculates them before character recognition),
    // so they may be replaced later by versions we calculate.
    const lineAllHeightTessStr = parseFloat(titleStrLine.match(/x_size\s+([\d.-]+)/)?.[1] || '15');
    const lineAscHeightTessStr = parseFloat(titleStrLine.match(/x_ascenders\s+([\d.-]+)/)?.[1] || '0');
    const lineDescHeightTessStr = parseFloat(titleStrLine.match(/x_descenders\s+([\d.-]+)/)?.[1] || '0');

    const lineAscHeightTess = lineAllHeightTessStr - lineDescHeightTessStr;

    // When Scribe exports lines with `null` `xHeight` values to HOCR, `x_ascenders` is omitted.
    let lineXHeightTess = null;
    if (lineAscHeightTessStr > 0) {
      lineXHeightTess = lineAllHeightTessStr - lineDescHeightTessStr - lineAscHeightTessStr;
    }

    const lineObj = new ocr.OcrLine(pageObj, linebox, baseline, lineAscHeightTess, lineXHeightTess);

    if (debugMode) lineObj.raw = match;

    const heightSmallCapsLine = [];

    /**
   * @param {string} match
   */
    function convertWordCharLevel(match) {
      let text = '';

      const titleStrWord = match.match(/title=['"]([^'"]+)/)?.[1];
      const confMatch = titleStrWord.match(/(?:;|\s)x_wconf\s+(\d+)/);
      let wordConf = 0;
      if (confMatch != null) {
        wordConf = parseInt(confMatch[1]);
      }

      const italic = /<\/em>\s*<\/span>/.test(match);

      const wordID = match.match(/id=['"]([^'"]*)['"]/i)?.[1];

      const fontName = match.match(/^[^>]+?x_font\s*([\w-]+)/)?.[1];

      const fontFamily = determineSansSerif(fontName);

      const it = match.matchAll(charRegex);
      let letterArr = [...it];
      // let bboxes = Array(letterArr.length);
      const cuts = Array(letterArr.length);

      // Unlike Abbyy, which generally identifies small caps as lowercase letters (and identifies small cap text explicitly as a formatting property),
      // Tesseract (at least the Legacy model) reports them as upper-case letters.
      const wordStr = letterArr.map((x) => x[2]).join('');
      let smallCaps = false;
      let smallCapsTitle = false;
      let minLetterIndex = 0;
      if (!/[a-z]/.test(wordStr) && /[A-Z].?[A-Z]/.test(wordStr)) {
        // Filter to only include letters
        const filterArr = wordStr.split('').map((x) => /[a-z]/i.test(x));
        const letterArrSub = letterArr.filter((x, y) => filterArr[y]);

        // Index of first letter (the only capital letter for title case)
        minLetterIndex = Math.min(...[...Array(filterArr.length).keys()].filter((x, y) => filterArr[y]));

        const wordBboxesTop = letterArrSub.map((x) => parseInt(x[1].match(/\d+ (\d+)/)[1]));
        const wordBboxesBottom = letterArrSub.map((x) => parseInt(x[1].match(/\d+ \d+ \d+ (\d+)/)[1]));

        // Check for small caps words in title case (first letter larger than all following letters)
        if (Math.min(...letterArrSub.map((x) => x[1].match(/\d+ (\d+)/)[1]).map((x) => Math.sign((x - wordBboxesBottom[0]) + ((wordBboxesBottom[0] - wordBboxesTop[0]) * 0.90))).slice(1)) === 1) {
          smallCaps = true;
          smallCapsTitle = true;
          for (let i = 1; i < wordBboxesTop.length; i++) {
            heightSmallCapsLine.push(wordBboxesBottom[i] - wordBboxesTop[i]);
          }
          // Check for small caps words in lowercase (all letters the same size, which is around the same size as small caps in previous words in line)
          // The 10% margin accounts for random variation in general, however is also important since rounded letters (e.g. "O") are taller but
          // less common, so will almost always exceed the median.
        } else {
          const letterHeightArr = wordBboxesBottom.map((x, y) => x - wordBboxesTop[y]);
          const heightSmallCapsLineMedian = quantile(heightSmallCapsLine, 0.5);
          if (heightSmallCapsLineMedian && letterHeightArr.filter((x) => x > heightSmallCapsLineMedian * 1.1).length == 0) {
            smallCaps = true;
          }
        }
      }

      const bboxes = letterArr.map((x) => x[1].match(/(\d+) (\d+) (\d+) (\d+)/).slice(1, 5).map((y) => parseInt(y)));

      // Adjust box such that top/bottom approximate those coordinates at the leftmost point
      const lineboxAdj = linebox.slice();

      if (baseline[0] < 0) {
        lineboxAdj[1] -= (lineboxAdj[2] - lineboxAdj[0]) * baseline[0];
      } else {
        lineboxAdj[3] -= (lineboxAdj[2] - lineboxAdj[0]) * baseline[0];
      }

      // Tesseract does not split superscript footnote references into separate words, so that happens here
      let letterArrSuper = [];
      // if (/^\W?[a-z]/i.test(wordStr) && /\d$/i.test(wordStr)) {
      if (/\d$/i.test(wordStr)) {
        const numsN = wordStr.match(/\d+$/)[0].length;

        const expectedBaseline = (bboxes[0][0] + (bboxes[bboxes.length - 1][2] - bboxes[0][0]) / 2 - lineboxAdj[0]) * baseline[0] + baseline[1] + lineboxAdj[3];
        const lineAscHeight = expectedBaseline - lineboxAdj[1];

        let baseN = 0;
        for (let i = bboxes.length - 1; i >= 0; i--) {
          if (bboxes[i][3] < expectedBaseline - lineAscHeight / 4) {
            baseN++;
          } else {
            break;
          }
        }

        const superN = Math.min(numsN, baseN);

        if (superN > 0) {
          letterArrSuper = letterArr.slice(letterArr.length - superN, letterArr.length);
          letterArr = letterArr.slice(0, letterArr.length - superN);
        }
      }

      const charObjArr = [];

      for (let j = 0; j < letterArr.length; j++) {
        let contentStrLetter = letterArr[j][2];

        // If word is small caps, convert letters to lower case.
        if (smallCaps && (!smallCapsTitle || j > minLetterIndex)) {
          contentStrLetter = contentStrLetter.toLowerCase();
        }

        // Handle characters escaped in XML
        contentStrLetter = unescapeXml(contentStrLetter);

        const charObj = new ocr.OcrChar(contentStrLetter, bboxes[j]);
        charObjArr.push(charObj);

        text += contentStrLetter;
      }
      text = text ?? '';
      text = text.trim();

      let wordXML = match.match(wordElementRegex)[0];

      if (letterArrSuper.length > 0) {
        // Calculate new bounding boxes

        if (text) {
          const bboxesCore = letterArr.map((x) => x[1].match(/(\d+) (\d+) (\d+) (\d+)/).slice(1, 5));
          const wordBoxCore = new Array(4);
          wordBoxCore[0] = Math.min(...bboxesCore.map((x) => x[0]));
          wordBoxCore[1] = Math.min(...bboxesCore.map((x) => x[1]));
          wordBoxCore[2] = Math.max(...bboxesCore.map((x) => x[2]));
          wordBoxCore[3] = Math.max(...bboxesCore.map((x) => x[3]));

          const wordObjCore = new ocr.OcrWord(lineObj, text, wordBoxCore, wordID);
          wordObjCore.chars = charObjArr;

          if (debugMode) wordObjCore.raw = match;

          if (smallCaps || italic || fontFamily !== 'Default') {
            if (smallCaps) {
              wordObjCore.style = 'small-caps';
            } else if (italic) {
              wordObjCore.style = 'italic';
            }
            if (fontFamily !== 'Default') {
              wordObjCore.font = fontFamily;
            }
          }

          wordObjCore.conf = wordConf;

          lineObj.words.push(wordObjCore);
        }

        const bboxesSuper = letterArrSuper.map((x) => x[1].match(/(\d+) (\d+) (\d+) (\d+)/)?.slice(1, 5).map((y) => parseInt(y)));
        const wordBoxSuper = new Array(4);
        wordBoxSuper[0] = Math.min(...bboxesSuper.map((x) => x[0]));
        wordBoxSuper[1] = Math.min(...bboxesSuper.map((x) => x[1]));
        wordBoxSuper[2] = Math.max(...bboxesSuper.map((x) => x[2]));
        wordBoxSuper[3] = Math.max(...bboxesSuper.map((x) => x[3]));

        const textSuper = letterArrSuper.map((x) => x[2]).join('');

        const wordObjSup = new ocr.OcrWord(lineObj, textSuper, wordBoxSuper, `${wordID}a`);

        if (debugMode) wordObjSup.raw = match;

        wordObjSup.conf = wordConf;

        wordObjSup.sup = true;

        lineObj.words.push(wordObjSup);

        return '';
      }
      if (text === '') return ('');

      const bboxesCore = letterArr.map((x) => x[1].match(/(\d+) (\d+) (\d+) (\d+)/)?.slice(1, 5).map((y) => parseInt(y)));
      const wordBoxCore = new Array(4);
      wordBoxCore[0] = Math.min(...bboxesCore.map((x) => x[0]));
      wordBoxCore[1] = Math.min(...bboxesCore.map((x) => x[1]));
      wordBoxCore[2] = Math.max(...bboxesCore.map((x) => x[2]));
      wordBoxCore[3] = Math.max(...bboxesCore.map((x) => x[3]));

      const wordObj = new ocr.OcrWord(lineObj, text, wordBoxCore, `${wordID}a`);

      wordObj.chars = charObjArr;

      if (debugMode) wordObj.raw = match;

      if (smallCaps || italic || fontFamily !== 'Default') {
        wordXML = `${wordXML.slice(0, -1)} style='`;
        if (smallCaps) {
          wordObj.style = 'small-caps';
        } else if (italic) {
          wordObj.style = 'italic';
        }
        if (fontFamily !== 'Default') {
          wordObj.font = fontFamily;
        }
      }

      wordObj.conf = wordConf;

      lineObj.words.push(wordObj);

      return '';
    }

    /**
     * @param {string} match
     */
    function convertWord(match) {
      const wordID = match.match(/id=['"]([^'"]*)['"]/i)?.[1];

      const wordSup = /<sup>/i.test(match);
      const wordDropCap = /<span class=['"]ocr_dropcap['"]>/i.test(match);

      let wordText;
      if (wordSup) {
        wordText = match.replace(/\s*<sup>/i, '').replace(/<\/sup>\s*/i, '').match(/>([^>]*)</)?.[1];
      } else if (wordDropCap) {
        wordText = match.replace(/\s*<span class=['"]ocr_dropcap['"]>/i, '').match(/>([^>]*)</)?.[1];
      } else {
        wordText = match.match(/>([^>]*)</)?.[1];
      }

      wordText = unescapeXml(wordText);

      if (!wordText) {
        return '';
      }

      const titleStrWord = match.match(/title=['"]([^'"]+)/)?.[1];

      if (!titleStrWord) {
        console.log(`Unable to process word, skipping: ${match}`);
        return '';
      }

      const wordBox = [...titleStrWord.matchAll(/bbox(?:es)?(\s+[\d-]+)(\s+[\d-]+)?(\s+[\d-]+)?(\s+[\d-]+)?/g)][0].slice(1, 5).map((x) => parseInt(x));

      const fontName = match.match(/^[^>]+?x_font\s*([\w-]+)/)?.[1];

      const fontFamily = determineSansSerif(fontName);

      const styleStr = match.match(/style=['"]([^'"]+)/)?.[1];

      let fontStyle = 'normal';
      if (styleStr && /italic/i.test(styleStr)) {
        fontStyle = 'italic';
      } else if (styleStr && /small-caps/i.test(styleStr)) {
        fontStyle = 'small-caps';
      }

      const confMatch = titleStrWord.match(/(?:;|\s)x_wconf\s+(\d+)/)?.[1] || '0';
      const wordConf = parseInt(confMatch) || 0;

      const wordObj = new ocr.OcrWord(lineObj, wordText, wordBox, `${wordID}a`);
      wordObj.style = fontStyle;
      if (fontFamily !== 'Default') {
        wordObj.font = fontFamily;
      }

      wordObj.conf = wordConf;

      lineObj.words.push(wordObj);

      return '';
    }

    if (charMode) {
      match = match.replaceAll(wordRegexCharLevel, convertWordCharLevel);
    } else {
      match = match.replaceAll(wordRegex, convertWord);
    }

    pageObj.lines.push(lineObj);

    return '';
  }

  ocrStr = ocrStr.replaceAll(lineRegex, convertLine);

  const angleRiseMedian = mean50(angleRisePage) || 0;

  const lineLeftAdj = [];
  for (let i = 0; i < lineLeft.length; i++) {
    lineLeftAdj.push(lineLeft[i] + angleRiseMedian * lineTop[i]);
  }

  pageObj.angle = Math.abs(rotateAngle) > 0.05 ? rotateAngle : Math.asin(angleRiseMedian) * (180 / Math.PI);

  const sinAngle = Math.sin(pageObj.angle * (Math.PI / 180));
  const shiftX = sinAngle * (pageDims.height * 0.5) * -1 || 0;

  let leftOut = quantile(lineLeft, 0.2) - shiftX;
  const leftAdjOut = quantile(lineLeftAdj, 0.2) - shiftX - leftOut;

  // With <5 lines either a left margin does not exist (e.g. a photo or title page) or cannot be reliably determined
  if (lineLeft.length < 5) {
    leftOut = null;
  }

  pageObj.left = leftOut;
  pageObj.leftAdj = leftAdjOut;

  // Transform bounding boxes if rotation is specified.
  // This option is used when an image is rotated before it is sent to Tesseract,
  // however the HOCR needs to be applied to the original image.
  if (Math.abs(rotateAngle) > 0.05) {
    for (let i = 0; i < pageObj.lines.length; i++) {
      ocr.rotateLine(pageObj.lines[i], rotateAngle);
    }
  }

  const warn = { char: charMode ? '' : 'char_warning' };

  return pass2({ pageObj, layoutBoxes: {}, warn });
}

const abbyyDropCapRegex = /<par dropCapCharsCount=['"](\d*)/i;
const abbyyLineBoxRegex = /<line baseline=['"](\d*)['"] l=['"](\d*)['"] t=['"](\d*)['"] r=['"](\d*)['"] b=['"](\d*)['"]>/i;
const abbyySplitRegex = /(?:<charParams[^>]*>\s*<\/charParams>)|(?:<\/formatting>\s*(?=<formatting))/ig;

const abbyyCharRegex = /(<formatting[^>]+>\s*)?<charParams l=['"](\d*)['"] t=['"](\d*)['"] r=['"](\d*)['"] b=['"](\d*)['"](?: suspicious=['"](\w*)['"])?[^>]*>([^<]*)<\/charParams>/ig;

/**
 * @param {Object} params
 * @param {string} params.ocrStr
 * @param {number} params.n
 */
export async function convertPageAbbyy({ ocrStr, n }) {
  // Return early if character-level data is not detected.
  // Unlike Tesseract HOCR (which by default returns word-level data which we can still use), Abbyy XML returns line-level data that is not usable.
  const pageDimsStr = ocrStr.match(/<page width=['"](\d+)['"] height=['"](\d+)['"]/);
  const pageDims = { height: parseInt(pageDimsStr[2]), width: parseInt(pageDimsStr[1]) };

  const pageObj = new ocr.OcrPage(n, pageDims);

  // This condition is met for actual character errors (xml data lacks character-level data), as well as for empty pages.
  // However, the error is only shown to the user if there are no pages with valid character data.
  if (!/<charParams/i.test(ocrStr)) {
    const warn = { char: 'char_error' };

    return {
      pageObj, fontMetricsObj: {}, layoutBoxes: {}, warn,
    };
  }

  const boxes = convertTableLayoutAbbyy(ocrStr);

  const lineLeft = [];
  const lineTop = [];

  function convertLineAbbyy(xmlLine, lineNum, n = 1) {
    const stylesLine = {};

    // Unlike Tesseract HOCR, Abbyy XML does not provide accurate metrics for determining font size, so they are calculated here.
    // Strangely, while Abbyy XML does provide a "baseline" attribute, it is often wildly incorrect (sometimes falling outside of the bounding box entirely).
    // One guess as to why is that coordinates calculated pre-dewarping are used along with a baseline calculated post-dewarping.
    // Regardless of the reason, baseline is recalculated here.
    const baselineSlopeArr = [];
    const baselineFirst = [];

    const xmlLinePreChar = xmlLine.match(/^[\s\S]*?(?=<charParams)/)?.[0];
    const xmlLineFormatting = xmlLinePreChar?.match(/<formatting[^>]+/)?.[0];
    const fontName = xmlLineFormatting?.match(/ff=['"]([^'"]*)/)?.[1];

    const fontFamily = determineSansSerif(fontName);

    let dropCap = false;
    const dropCapMatch = xmlLine.match(abbyyDropCapRegex);
    if (dropCapMatch != null && parseInt(dropCapMatch[1]) > 0) {
      dropCap = true;
    }

    let lineBoxArr = xmlLine.match(abbyyLineBoxRegex);
    if (lineBoxArr == null) { return (''); }
    lineBoxArr = [...lineBoxArr].map((x) => parseInt(x));
    // Only calculate baselines from lines 200px+.
    // This avoids short "lines" (e.g. page numbers) that often report wild values.
    if ((lineBoxArr[4] - lineBoxArr[2]) >= 200) {
      // angleRisePage.push(baseline[0]);
      lineLeft.push(lineBoxArr[2]);
      lineTop.push(lineBoxArr[3]);
    }

    // Unlike Tesseract, Abbyy XML does not have a native "word" unit (it provides only lines and letters).
    // Therefore, lines are split into words on either (1) a space character or (2) a change in formatting.

    // TODO: Investigate possible fix for too many words issue:
    // The reason for splitting letters at every formatting change is (1) this splits up superscripts from
    // the words they are attached to and (2) to split up normal and italic parts of text (even if not separated by a space),
    // as the canvas GUI currently only supports one font style per word.
    // Unfortunately, in some documents Abbyy has the nonsensical habbit of using formatting tags just to change font size
    // on a specific character (e.g. switching from font size 10.5 to 11 for a single period).
    // When this happens, the heuristic here results in too many words being created--not sure if there's an easy fix.

    // Replace character identified as tab with space (so it is split into separate word)
    // For whatever reason many non-tab values can be found in elements where isTab is true (e.g. "_", "....")
    xmlLine = xmlLine.replaceAll(/isTab=['"](?:1|true)['"][^>]*>[^<]+/ig, '> ');

    // These regex remove blank characters that occur next to changes in formatting to avoid making too many words.
    // Note: Abbyy is inconsistent regarding where formatting elements are placed.
    // Sometimes the <format> comes after the space between words, and sometimes it comes before the space between words.
    xmlLine = xmlLine.replaceAll(/(<\/formatting><formatting[^>]*>\s*)<charParams[^>]*>\s*<\/charParams>/ig, '$1');
    xmlLine = xmlLine.replaceAll(/<charParams[^>]*>\s*<\/charParams>(\s*<\/formatting><formatting[^>]*>\s*)/ig, '$1');

    // xmlLine = xmlLine.replaceAll(/(\<\/formatting\>\<formatting[^\>]*\>)(\s*<charParams[^\>]*\>\.\<\/charParams\>)\<\/formatting\>/ig, "$1")

    const wordStrArr1 = xmlLine.split(abbyySplitRegex);

    // Account for special cases:
    // 1. Filter off any array elements that do not have a character.
    //    (This can happen ocassionally, for example when multiple spaces are next to eachother.)
    //    TODO: This will drop formatting information in edge cases--e.g. if a formatting element is followed by multiple spaces.
    //    However, hopefully these are uncommon enough that they should not be a big issue.
    // 2. Period with its own "word" due to being wrapped in separate <formatting> tags
    //    This odd behavior appears around to superscripts, and makes sense when normal text is followed by a superscript followed by a period.
    //    However, it also happens when normal text is followed by a period followed by a superscript (the normal behavior),
    //    and it does not make sense for a period to get its own word in this case.

    const wordStrArr = [];
    for (let i = 0; i < wordStrArr1.length; i++) {
      const wordStrArrI = wordStrArr1[i];
      const wordMatch = wordStrArrI.match(/>([^<>]+?)(?=<\/charParams>)/g)?.map((x) => x.substring(1));
      if (!wordMatch) {
        continue;
      } else if (wordMatch.length === 1) {
        if (wordMatch[0] === '.') {
          if (wordStrArr.length > 0 && !/superscript=['"](1|true)/i.test(wordStrArr[wordStrArr.length - 1])) {
            wordStrArr[wordStrArr.length - 1] = wordStrArr[wordStrArr.length - 1] + wordStrArrI.replace(/(<formatting[^>]+>\s*)/i, '');
            continue;
          }
        }
      }
      wordStrArr.push(wordStrArrI);
    }

    if (wordStrArr.length === 0) return (['', 0]);

    const bboxes = Array(wordStrArr.length);
    let text = Array(wordStrArr.length);

    /** @type {Array<Array<OcrChar>>} */
    const charObjArrLine = Array(wordStrArr.length);
    text = text.fill('');
    let styleArr = Array(wordStrArr.length);
    styleArr = styleArr.fill('normal');
    const wordSusp = Array(wordStrArr.length);
    wordSusp.fill(false);

    for (let i = 0; i < wordStrArr.length; i++) {
      const wordStr = wordStrArr[i];
      const letterArr = [...wordStr.matchAll(abbyyCharRegex)];

      if (typeof (letterArr[0][1]) !== 'undefined') {
        if (dropCap && i === 0) {
          styleArr[i] = 'dropcap';
        } else if (/superscript=['"](1|true)/i.test(letterArr[0][1])) {
          styleArr[i] = 'sup';
        } else if (/italic=['"](1|true)/i.test(letterArr[0][1])) {
          styleArr[i] = 'italic';
          stylesLine.italic = true;
        } else if (/smallcaps=['"](1|true)/i.test(letterArr[0][1])) {
          styleArr[i] = 'small-caps';
          stylesLine['small-caps'] = true;
        } else {
          styleArr[i] = 'normal';
          stylesLine.normal = true;
        }
      } else if (i > 0) {
        if (styleArr[i - 1] === 'dropcap') {
          styleArr[i] = 'normal';
        } else {
          styleArr[i] = styleArr[i - 1];
        }
      }

      // Abbyy will sometimes misidentify capital letters immediately following drop caps as small caps,
      // when they are only small in relation to the drop cap (rather than the main text).
      let dropCapFix = false;
      if (dropCap && i === 1 && styleArr[i] === 'small-caps') {
        styleArr[i] = 'normal';
        dropCapFix = true;
      }

      bboxes[i] = [];

      charObjArrLine[i] = [];

      for (let j = 0; j < letterArr.length; j++) {
        // Skip letters placed at coordinate 0 (not sure why this happens)
        if (letterArr[j][2] === '0') { continue; }

        bboxes[i][j] = [];
        bboxes[i][j].push(parseInt(letterArr[j][2]));
        bboxes[i][j].push(parseInt(letterArr[j][3]));
        bboxes[i][j].push(parseInt(letterArr[j][4]));
        bboxes[i][j].push(parseInt(letterArr[j][5]));

        let letterSusp = false;
        if (letterArr[j][6] === '1' || letterArr[j][6] === 'true') {
          wordSusp[i] = true;
          letterSusp = true;
        }

        if (dropCapFix) {
          letterArr[j][7] = letterArr[j][7].toUpperCase();
        }

        // Handle characters escaped in XML
        letterArr[j][7] = unescapeXml(letterArr[j][7]);

        const contentStrLetter = letterArr[j][7];

        const ascChar = ascCharArr.includes(contentStrLetter);
        const xChar = xCharArr.includes(contentStrLetter);

        if ((ascChar || xChar) && !letterSusp && !dropCapFix && !(dropCap && i === 0)) {
          // baselineHeightArr.push(bboxes[i][j][3]);
          // To calculate the slope of the baseline (and therefore image angle) the position of each glyph that starts (approximately) on the
          // baseline is compared to the first such glyph.  This is less precise than a true "best fit" approach, but hopefully with enough data
          // points it will all average out.
          if (baselineFirst.length === 0) {
            baselineFirst.push(bboxes[i][j][0], bboxes[i][j][3]);
          } else {
            baselineSlopeArr.push((bboxes[i][j][3] - baselineFirst[1]) / (bboxes[i][j][0] - baselineFirst[0]));
          }
        }

        text[i] += contentStrLetter;

        const charObj = new ocr.OcrChar(contentStrLetter, bboxes[i][j]);

        charObjArrLine[i].push(charObj);
      }
    }

    // While Abbyy XML already provides line bounding boxes, these have been observed to be (at times)
    // completely different than a bounding box calculated from a union of all letters in the line.
    // Therefore, the line bounding boxes are recaclculated here.
    const lineBoxArrCalc = new Array(4);
    // reduce((acc, val) => acc.concat(val), []) is used as a drop-in replacement for flat() with significantly better performance
    lineBoxArrCalc[0] = Math.min(...bboxes.reduce((acc, val) => acc.concat(val), []).map((x) => x[0]).filter((x) => x > 0));
    lineBoxArrCalc[1] = Math.min(...bboxes.reduce((acc, val) => acc.concat(val), []).map((x) => x[1]).filter((x) => x > 0));
    lineBoxArrCalc[2] = Math.max(...bboxes.reduce((acc, val) => acc.concat(val), []).map((x) => x[2]).filter((x) => x > 0));
    lineBoxArrCalc[3] = Math.max(...bboxes.reduce((acc, val) => acc.concat(val), []).map((x) => x[3]).filter((x) => x > 0));

    const baselineSlope = quantile(baselineSlopeArr, 0.5) || 0;

    // baselinePoint should be the offset between the bottom of the line bounding box, and the baseline at the leftmost point
    let baselinePoint = baselineFirst[1] - lineBoxArrCalc[3];
    if (baselineSlope < 0) {
      baselinePoint -= baselineSlope * (baselineFirst[0] - lineBoxArrCalc[0]);
    }
    baselinePoint = baselinePoint || 0;

    // In general, the bounding box calculated here from the individual word boundign boxes is used.
    // In a small number of cases the bounding box cannot be calculated because all individual character-level bounding boxes are at 0 (and therefore skipped)
    // In this case the original line-level bounding box from Abbyy is used
    const lineBoxArrOut = Number.isFinite(lineBoxArrCalc[0]) && Number.isFinite(lineBoxArrCalc[1]) && Number.isFinite(lineBoxArrCalc[2]) && Number.isFinite(lineBoxArrCalc[3])
      ? lineBoxArrCalc : lineBoxArr.slice(2, 6);

    const baselineOut = [round6(baselineSlope), Math.round(baselinePoint)];

    const lineObj = new ocr.OcrLine(pageObj, lineBoxArrOut, baselineOut);

    let lettersKept = 0;
    for (let i = 0; i < text.length; i++) {
      if (text[i].trim() == '') { continue; }
      const bboxesI = bboxes[i];

      // Abbyy-specific fix:
      // Only values > 0 are considered, since Abbyy has been observed to frequently return incorrect "0" coordinates.
      // This frequently (but not always) occurs with superscripts.
      // If this filter leaves no remaining left/right/top/bottom coordinates, the word is skipped entirely.
      // TODO: Figure out why this happens and whether these glyphs should be dropped completely.
      const bboxesILeft = Math.min(...bboxesI.map((x) => x[0]).filter((x) => x > 0));
      const bboxesIRight = Math.max(...bboxesI.map((x) => x[2]).filter((x) => x > 0));
      const bboxesITop = Math.min(...bboxesI.map((x) => x[1]).filter((x) => x > 0));
      const bboxesIBottom = Math.max(...bboxesI.map((x) => x[3]).filter((x) => x > 0));

      if (!Number.isFinite(bboxesITop) || !Number.isFinite(bboxesIBottom) || !Number.isFinite(bboxesILeft) || !Number.isFinite(bboxesIRight)) {
        continue;
      }

      const id = `word_${n + 1}_${lineNum + 1}_${i + 1}`;

      const wordObj = new ocr.OcrWord(lineObj, text[i], [bboxesILeft, bboxesITop, bboxesIRight, bboxesIBottom], id);
      wordObj.chars = charObjArrLine[i];
      wordObj.conf = wordSusp[i] ? 0 : 100;

      console.assert(wordObj.chars.length === text[i].length, `Likely parsing error for word: ${id}. Number of letters in text does not match number of \`ocrChar\` objects.`);

      if (styleArr[i] === 'italic') {
        wordObj.style = 'italic';
      } else if (styleArr[i] === 'small-caps') {
        wordObj.style = 'small-caps';
      }

      if (fontFamily !== 'Default') {
        wordObj.font = fontFamily;
      }

      if (styleArr[i] === 'sup') {
        wordObj.sup = true;
      } else if (styleArr[i] === 'dropcap') {
        wordObj.dropcap = true;
      }

      lineObj.words.push(wordObj);

      lettersKept++;
    }

    // If there are no letters in the line, drop the entire line element
    if (lettersKept === 0) return (['', 0]);

    pageObj.lines.push(lineObj);

    return (['non-empty value', baselineSlope]);
  }

  const lineStrArr = ocrStr.split(/<\/line>/);

  const angleRisePage = [];
  for (let i = 0; i < lineStrArr.length; i++) {
    const lineInt = convertLineAbbyy(lineStrArr[i], i, n);
    if (lineInt[0] == '') continue;
    angleRisePage.push(lineInt[1]);
  }

  const angleRiseMedian = mean50(angleRisePage) || 0;

  const angleOut = Math.asin(angleRiseMedian) * (180 / Math.PI);

  pageObj.angle = angleOut;

  const lineLeftAdj = [];
  for (let i = 0; i < lineLeft.length; i++) {
    lineLeftAdj.push(lineLeft[i] + angleRiseMedian * lineTop[i]);
  }
  let leftOut = quantile(lineLeft, 0.2);
  const leftAdjOut = quantile(lineLeftAdj, 0.2) - leftOut;
  // With <5 lines either a left margin does not exist (e.g. a photo or title page) or cannot be reliably determined
  if (lineLeft.length < 5) {
    leftOut = null;
  }

  pageObj.left = leftOut;
  pageObj.leftAdj = leftAdjOut;

  return pass2({ pageObj, layoutBoxes: boxes });
}

const stextSplitRegex = /(?:<char[^>]*?c=['"]\s+['"]\/>)|(?:<\/font>\s*(?=<font))/ig;
// The "quad" attribute includes 8 numbers (x and y coordinates for all 4 corners) however we only use capturing groups for 4
const stextCharRegex = /(<font[^>]+>\s*)?<char quad=['"](\s*[\d.-]+)(\s*[\d.-]+)(?:\s*[\d.-]+)(?:\s*[\d.-]+)(?:\s*[\d.-]+)(?:\s*[\d.-]+)(\s*[\d.-]+)(\s*[\d.-]+)[^>]*?y=['"]([\d.-]+)['"][^>]*?c=['"]([^'"]+)['"]\s*\/>/ig;

// Conversion function for "stext" (or "structured text" output from mupdf)
// This format is more similar to Abbyy XML and is based on that parsing code.
// The following features were removed (compared with Abbyy XML):
// - Drop cap detection
// - Superscript detection

/**
 * @param {Object} params
 * @param {string} params.ocrStr
 * @param {number} params.n
 */
export async function convertPageStext({ ocrStr, n }) {
  const pageDimsMatch = ocrStr.match(/<page .+?width=['"]([\d.-]+)['"] height=['"]([\d.-]+)['"]/);
  const pageDims = { height: parseInt(pageDimsMatch[2]), width: parseInt(pageDimsMatch[1]) };

  const lineLeft = [];
  const lineTop = [];

  const pageObj = new ocr.OcrPage(n, pageDims);

  /**
   * @param {string} xmlLine
   * @param {number} lineNum
   * @param {number} n
   */
  function convertLineStext(xmlLine, lineNum, n = 1) {
    const stylesLine = {};

    // Unlike Tesseract HOCR, Abbyy XML does not provide accurate metrics for determining font size, so they are calculated here.
    // Strangely, while Abbyy XML does provide a "baseline" attribute, it is often wildly incorrect (sometimes falling outside of the bounding box entirely).
    // One guess as to why is that coordinates calculated pre-dewarping are used along with a baseline calculated post-dewarping.
    // Regardless of the reason, baseline is recalculated here.
    const lineAllHeightArr = [];
    const baselineSlopeArr = [];
    const baselineFirst = [];

    const xmlLinePreChar = xmlLine.match(/^[\s\S]*?(?=<char)/)?.[0];
    if (!xmlLinePreChar) { return (''); }

    const xmlLineFormatting = xmlLinePreChar?.match(/<font[^>]+/)?.[0];
    const fontName = xmlLineFormatting?.match(/name=['"]([^'"]*)/)?.[1];
    const fontSize = parseFloat(xmlLineFormatting?.match(/size\=['"]([^'"]*)/)?.[1]);

    const fontFamily = determineSansSerif(fontName);

    // Currently no method of detecting drop caps for stext
    const dropCap = false;
    // let dropCapMatch = xmlLine.match(abbyyDropCapRegex);
    // if (dropCapMatch != null && parseInt(dropCapMatch[1]) > 0) {
    //   dropCap = true;
    // }

    let lineBoxArr = [...xmlLinePreChar.matchAll(/bbox(?:es)?=['"](\s*[\d.-]+)(\s*[\d.-]+)?(\s*[\d.-]+)?(\s*[\d.-]+)?/g)][0].slice(1, 5).map((x) => Math.max(parseFloat(x), 0));

    if (lineBoxArr == null) { return (''); }
    lineBoxArr = [...lineBoxArr].map((x) => parseInt(x));
    // Only calculate baselines from lines 200px+.
    // This avoids short "lines" (e.g. page numbers) that often report wild values.
    if ((lineBoxArr[4] - lineBoxArr[2]) >= 200) {
      // angleRisePage.push(baseline[0]);
      lineLeft.push(lineBoxArr[2]);
      lineTop.push(lineBoxArr[3]);
    }

    // These regex remove blank characters that occur next to changes in formatting to avoid making too many words.
    // stext is confirmed to (at least sometimes) change formatting before a space character rather than after
    xmlLine = xmlLine.replaceAll(/(<\/font>\s*<font[^>]*>\s*)<char[^>]*?c=['"]\s+['"]\/>/ig, '$1');
    xmlLine = xmlLine.replaceAll(/<char[^>]*?c=['"]\s+['"]\/>(\s*<\/font>\s*<font[^>]*>\s*)/ig, '$1');

    // Remove spaces that are the first characters of words
    xmlLine = xmlLine.replaceAll(/(<font[^>]*>\s*)<char[^>]*?c=['"]\s+['"]\/>/ig, '$1');

    // Unlike Tesseract, stext does not have a native "word" unit (it provides only lines and letters).
    // Therefore, lines are split into words on either (1) a space character or (2) a change in formatting.
    const wordStrArr = xmlLine.split(stextSplitRegex);

    if (wordStrArr.length === 0) return (['', 0]);

    const bboxes = Array(wordStrArr.length);
    // let cuts = Array(wordStrArr.length);
    let text = Array(wordStrArr.length);
    text = text.fill('');
    let styleArr = Array(wordStrArr.length);
    styleArr = styleArr.fill('normal');

    for (let i = 0; i < wordStrArr.length; i++) {
      const wordStr = wordStrArr[i];
      const letterArr = [...wordStr.matchAll(stextCharRegex)];
      if (letterArr.length === 0) continue;
      if (typeof (letterArr[0][1]) !== 'undefined') {
        if (dropCap && i === 0) {
          styleArr[i] = 'dropcap';
        // } else if (/superscript\=[\'\"](1|true)/i.test(letterArr[0][1])) {
        //   styleArr[i] = "sup";
        } else if (/italic/i.test(letterArr[0][1])) {
          styleArr[i] = 'italic';
          stylesLine.italic = true;
        } else if (/small\W?cap/i.test(letterArr[0][1])) {
          styleArr[i] = 'small-caps';
          stylesLine['small-caps'] = true;
        } else {
          styleArr[i] = 'normal';
          stylesLine.normal = true;
        }
      } else if (i > 0) {
        if (styleArr[i - 1] === 'dropcap') {
          styleArr[i] = 'normal';
        } else {
          styleArr[i] = styleArr[i - 1];
        }
      }

      bboxes[i] = [];

      for (let j = 0; j < letterArr.length; j++) {
        bboxes[i][j] = [];
        bboxes[i][j].push(Math.round(parseFloat(letterArr[j][2])));
        bboxes[i][j].push(Math.round(parseFloat(letterArr[j][3])));
        bboxes[i][j].push(Math.round(parseFloat(letterArr[j][4])));
        bboxes[i][j].push(Math.round(parseFloat(letterArr[j][5])));
        // The 5th element is the y coordinate of the baseline, which is not in the Abbyy version
        bboxes[i][j].push(Math.round(parseFloat(letterArr[j][6])));

        // All text in stext is considered correct/high confidence
        const letterSusp = false;

        const contentStrLetter = letterArr[j][7];
        text[i] = text[i] + contentStrLetter;

        lineAllHeightArr.push(bboxes[i][j][3] - bboxes[i][j][1]);
        if (!letterSusp && !(dropCap && i === 0)) {
          // To calculate the slope of the baseline (and therefore image angle) the position of each glyph that starts (approximately) on the
          // baseline is compared to the first such glyph.  This is less precise than a true "best fit" approach, but hopefully with enough data
          // points it will all average out.
          if (baselineFirst.length === 0) {
            baselineFirst.push(bboxes[i][j][0], bboxes[i][j][4]);
          } else {
            baselineSlopeArr.push((bboxes[i][j][4] - baselineFirst[1]) / (bboxes[i][j][0] - baselineFirst[0]));
          }
        }
      }
    }

    // NOTE: This section can probably be deleted for stext as it seems specific to Abbyy
    // While Abbyy XML already provides line bounding boxes, these have been observed to be (at times)
    // completely different than a bounding box calculated from a union of all letters in the line.
    // Therefore, the line bounding boxes are recaclculated here.
    const lineBoxArrCalc = new Array(4);
    // reduce((acc, val) => acc.concat(val), []) is used as a drop-in replacement for flat() with significantly better performance
    lineBoxArrCalc[0] = Math.min(...bboxes.reduce((acc, val) => acc.concat(val), []).map((x) => x[0]).filter((x) => x > 0));
    lineBoxArrCalc[1] = Math.min(...bboxes.reduce((acc, val) => acc.concat(val), []).map((x) => x[1]).filter((x) => x > 0));
    lineBoxArrCalc[2] = Math.max(...bboxes.reduce((acc, val) => acc.concat(val), []).map((x) => x[2]).filter((x) => x > 0));
    lineBoxArrCalc[3] = Math.max(...bboxes.reduce((acc, val) => acc.concat(val), []).map((x) => x[3]).filter((x) => x > 0));

    const baselineSlope = quantile(baselineSlopeArr, 0.5) || 0;

    // baselinePoint should be the offset between the bottom of the line bounding box, and the baseline at the leftmost point
    let baselinePoint = baselineFirst[1] - lineBoxArrCalc[3];
    if (baselineSlope < 0) {
      baselinePoint -= baselineSlope * (baselineFirst[0] - lineBoxArrCalc[0]);
    }
    baselinePoint = baselinePoint || 0;

    // In a small number of cases the bounding box cannot be calculated because all individual character-level bounding boxes are at 0 (and therefore skipped)
    // In this case the original line-level bounding box from Abbyy is used
    const lineBoxOut = Number.isFinite(lineBoxArrCalc[0]) && Number.isFinite(lineBoxArrCalc[1]) && Number.isFinite(lineBoxArrCalc[2])
      && Number.isFinite(lineBoxArrCalc[3]) ? lineBoxArrCalc : lineBoxArr.slice(2, 6);

    const baselineOut = [round6(baselineSlope), Math.round(baselinePoint)];

    // TODO: This is very back-of-the-napkin, should figure out how to be more precise.
    const letterHeightOut = fontSize * 0.6;

    const lineObj = new ocr.OcrLine(pageObj, lineBoxOut, baselineOut, letterHeightOut, null);

    let lettersKept = 0;
    for (let i = 0; i < text.length; i++) {
      if (text[i].trim() == '') { continue; }
      const bboxesI = bboxes[i];

      const bboxesILeft = Math.min(...bboxesI.map((x) => x[0]));
      const bboxesIRight = Math.max(...bboxesI.map((x) => x[2]));
      const bboxesITop = Math.min(...bboxesI.map((x) => x[1]));
      const bboxesIBottom = Math.max(...bboxesI.map((x) => x[3]));

      const id = `word_${n + 1}_${lineNum + 1}_${i + 1}`;

      const wordText = unescapeXml(text[i]);

      const wordObj = new ocr.OcrWord(lineObj, wordText, [bboxesILeft, bboxesITop, bboxesIRight, bboxesIBottom], id);

      // There is no confidence information in stext.
      // Confidence is set to 100 simply for ease of reading (to avoid all red text if the default was 0 confidence).
      wordObj.conf = 100;

      if (styleArr[i] === 'italic') {
        wordObj.style = 'italic';
      } else if (styleArr[i] === 'small-caps') {
        wordObj.style = 'small-caps';
      }

      if (fontFamily !== 'Default') {
        wordObj.font = fontFamily;
      }

      if (styleArr[i] === 'sup') {
        wordObj.sup = true;
      } else if (styleArr[i] === 'dropcap') {
        wordObj.dropcap = true;
      }

      lineObj.words.push(wordObj);

      lettersKept++;
    }

    // If there are no letters in the line, drop the entire line element
    if (lettersKept === 0) return (['', 0]);

    pageObj.lines.push(lineObj);
    return (['non-empty value', baselineSlope]);
  }

  const lineStrArr = ocrStr.split(/<\/line>/);

  const angleRisePage = [];
  for (let i = 0; i < lineStrArr.length; i++) {
    const lineInt = convertLineStext(lineStrArr[i], i, n);
    if (lineInt[0] == '') continue;
    angleRisePage.push(lineInt[1]);
  }

  const angleRiseMedian = mean50(angleRisePage) || 0;

  const angleOut = Math.asin(angleRiseMedian) * (180 / Math.PI);

  const lineLeftAdj = [];
  for (let i = 0; i < lineLeft.length; i++) {
    lineLeftAdj.push(lineLeft[i] + angleRiseMedian * lineTop[i]);
  }
  let leftOut = quantile(lineLeft, 0.2);
  const leftAdjOut = quantile(lineLeftAdj, 0.2) - leftOut;
  // With <5 lines either a left margin does not exist (e.g. a photo or title page) or cannot be reliably determined
  if (lineLeft.length < 5) {
    leftOut = null;
  }

  pageObj.angle = angleOut;
  pageObj.left = leftOut;
  pageObj.leftAdj = leftAdjOut;

  return pass2({ pageObj, layoutBoxes: {} });
}

/**
 * @param {string} ocrStr
 */
function convertTableLayoutAbbyy(ocrStr) {
  // Note: This assumes that block elements are not nested within table block elements
  // Not sure if this is true or not
  const tableRegex = /<block blockType=["']Table[\s\S]+?(?:<\/block>\s*)/ig;

  const tables = ocrStr.match(tableRegex);

  if (!tables) return {};

  const boxes = {};

  for (let i = 0; i < tables.length; i++) {
    let tableBoxes = {};

    const table = tables[i];
    const tableCoords = table.match(/<block blockType=['"]Table['"][^>]*?l=['"](\d+)['"] t=['"](\d+)['"] r=['"](\d+)['"] b=['"](\d+)['"]/i)?.slice(1, 5).map((x) => parseInt(x));

    let leftLast = tableCoords?.[0];

    const rows = table.match(/<row[\s\S]+?(?:<\/row>\s*)/g);

    // Columns widths are calculated using the cells in a single row.
    // The first row is used unless it contains cells spanning multiple columns,
    // in which case the second row is used.
    const firstRow = rows?.[1] && /colSpan/.test(rows[0]) ? rows[1] : rows?.[0];

    const firstRowCells = firstRow?.match(/<cell[\s\S]+?(?:<\/cell>\s*)/ig);

    if (leftLast == null || leftLast == undefined || !firstRowCells) {
      console.warn('Failed to parse table:');
      console.warn(table);
      continue;
    }

    for (let j = 0; j < firstRowCells.length; j++) {
      const cell = firstRowCells[j];
      const cellWidth = parseInt(cell.match(/width=[\'\"](\d+)[\'\"]/)?.[1]);

      const id = getRandomAlphanum(10);

      const cellLeft = leftLast;
      const cellRight = leftLast + cellWidth;

      leftLast = cellRight;

      const priority = Object.keys(boxes).length + Object.keys(tableBoxes).length + 1;

      tableBoxes[id] = new LayoutBox(priority, [cellLeft, tableCoords[1], cellRight, tableCoords[3]]);
      tableBoxes[id].type = 'dataColumn';
      tableBoxes[id].table = i;
    }

    // Abbyy sometimes provides column widths that are incorrect
    // If the column widths do not add up to the table width, the column widths are re-caculated from scratch.
    if (Math.abs(leftLast - tableCoords[2]) > 10) {
      let colLeftArr = [];
      let colRightArr = [];

      let colsWithData = 0;
      for (let j = 0; j < rows.length; j++) {
        const cells = rows[j].match(/<cell[\s\S]+?(?:<\/cell>\s*)/ig);
        for (let k = 0; k < cells.length; k++) {
          // Extract coordinates for every element in the cell with coordinates
          const coordsArrStr = cells[k].match(/l=['"](\d+)['"] t=['"](\d+)['"] r=['"](\d+)['"] b=['"](\d+)['"]/ig);
          if (!coordsArrStr) continue;
          const coordsArr = coordsArrStr.map((x) => x.match(/\d+/g).map((y) => parseInt(y)));
          const cellLeft = Math.min(...coordsArr.map((x) => x[0]));
          const cellRight = Math.max(...coordsArr.map((x) => x[2]));
          if (!colLeftArr[k]) {
            colLeftArr[k] = [];
            colRightArr[k] = [];
            colsWithData++;
          }
          colLeftArr[k].push(cellLeft);
          colRightArr[k].push(cellRight);
        }
      }

      // Columns that contain no data are removed
      colLeftArr = colLeftArr.filter((x) => x);
      colRightArr = colRightArr.filter((x) => x);

      // Calculate the minimum left bound of each column
      const colLeftMin = colLeftArr.map((x) => Math.min(...x));

      // Calculate the max right bound of each column, after removing observations past the minimum left bound of the next column.
      // This filter is intended to remove cells that span multiple rows.
      const colRightMax = [];
      for (let j = 0; j < colRightArr.length; j++) {
        const colRightArrJ = j + 1 === colRightArr.length ? colRightArr[j] : colRightArr[j].filter((x) => x < colLeftMin[j + 1]);
        colRightMax.push(Math.max(...colRightArrJ));
      }

      // Re-create boxes
      tableBoxes = {};
      for (let j = 0; j < colLeftArr.length; j++) {
        let cellLeft;
        if (j === 0) {
          cellLeft = tableCoords[0];
        } else if (!Number.isFinite(colRightMax[j - 1])) {
          cellLeft = Math.round(colLeftMin[j]);
        } else {
          cellLeft = Math.round((colLeftMin[j] + colRightMax[j - 1]) / 2);
        }

        let cellRight;
        if (j + 1 === colLeftArr.length) {
          cellRight = tableCoords[2];
        } else if (!Number.isFinite(colRightMax[j])) {
          cellRight = colLeftMin[j + 1];
        } else {
          cellRight = Math.round((colLeftMin[j + 1] + colRightMax[j]) / 2);
        }

        const id = getRandomAlphanum(10);

        const priority = Object.keys(boxes).length + Object.keys(tableBoxes).length + 1;

        tableBoxes[id] = new LayoutBox(priority, [cellLeft, tableCoords[1], cellRight, tableCoords[3]]);
        tableBoxes[id].type = 'dataColumn';
        tableBoxes[id].table = i;
      }

      console.log(`Table width does not match sum of rows (${String(tableCoords[2])} vs ${String(leftLast)}), calculated new layout boxes using column contents.`);
    }

    Object.assign(boxes, tableBoxes);
  }

  return boxes;
}

/**
 * Pass 2 iterates over all words/letters in the OCR object, calculating statistics and applying corrections.
 * All OCR objects (Tesseract/Abbyy/Stext) should be run through this function before returning.
 *
 * @param {Object} params
 * @param {OcrPage} params.pageObj
 * @param {Object} params.layoutBoxes
 * @param {Object} [params.warn]
 */
function pass2({ pageObj, layoutBoxes, warn }) {
  /** @type {Object.<string, FontMetricsRawFamily>} */
  const fontMetricsRawPage = {};

  for (let i = 0; i < pageObj.lines.length; i++) {
    const lineObj = pageObj.lines[i];

    /** @type {Array<number>} */
    const lineAscHeightArr = [];
    /** @type {Array<number>} */
    const lineXHeightArr = [];
    /** @type {Array<number>} */
    const lineAllHeightArr = [];

    for (let j = 0; j < lineObj.words.length; j++) {
      const wordObj = lineObj.words[j];

      const letterArr = wordObj.text.split('');
      const charObjArr = wordObj.chars;

      // This condition should not occur, however has in the past due to parsing bugs.  Skipping to avoid entire program crashing if this occurs.
      if (wordObj.chars && wordObj.chars.length !== wordObj.text.length) continue;

      // Quotes at the start of a word are assumed to be opening quotes
      if (['"', "'"].includes(letterArr[0]) && letterArr.length > 1 && /[a-z\d]/i.test(letterArr[1])) {
        if (letterArr[0] === '"') {
          letterArr[0] = '“';
          if (charObjArr) charObjArr[0].text = '“';
        } else if (letterArr[0] === "'") {
          letterArr[0] = '‘';
          if (charObjArr) charObjArr[0].text = '‘';
        }
      }

      // Quotes at the end of a word are assumed to be closing quotes
      if (['"', "'"].includes(letterArr[letterArr.length - 1]) && letterArr.length > 1 && /[a-z\d]/i.test(letterArr[letterArr.length - 2])) {
        if (letterArr[letterArr.length - 1] === '"') {
          letterArr[letterArr.length - 1] = '”';
          if (charObjArr) charObjArr[letterArr.length - 1].text = '”';
        } else if (letterArr[letterArr.length - 1] === "'") {
          letterArr[letterArr.length - 1] = '’';
          if (charObjArr) charObjArr[letterArr.length - 1].text = '’';
        }
      }

      // Single quotes between two letters are assumed to be apostrophes
      for (let k = 0; k < letterArr.length; k++) {
        if (["'"].includes(letterArr[k]) && k > 0 && k + 1 < letterArr.length && /[a-z\d]/i.test(letterArr[k + 1]) && /[a-z\d]/i.test(letterArr[k - 1])) {
          letterArr[k] = '’';
          if (charObjArr) charObjArr[k].text = '’';
        }
      }

      // Calculate statistics from character metrics, if present
      if (wordObj.chars) {
        for (let k = 0; k < letterArr.length; k++) {
          const charObj = wordObj.chars[k];

          // Do not include superscripts, dropcaps, and low-confidence words in all statistics.
          // Low-confidence words are included for font size calculations, as some lines only contain low-confidence words.
          if (wordObj.sup || wordObj.dropcap) continue;

          const contentStrLetter = letterArr[k];
          const charHeight = charObj.bbox[3] - charObj.bbox[1];

          // Save character heights to array for font size calculations
          lineAllHeightArr.push(charHeight);
          if (ascCharArr.includes(contentStrLetter)) {
            lineAscHeightArr.push(charHeight);
          } else if (xCharArr.includes(contentStrLetter)) {
            lineXHeightArr.push(charHeight);
          }
        }
      }

      wordObj.text = letterArr.join('');
    }

    const lineAllHeight = Math.max(...lineAllHeightArr);
    const lineAscHeight = quantile(lineAscHeightArr, 0.5);
    const lineXHeight = quantile(lineXHeightArr, 0.5);

    // TODO: For Tesseract these are often already filled in by the engine.
    // While the calculated values are more reliable, we may want to defer to the Tesseract values at some point as a fallback.
    if (lineAscHeight) lineObj.ascHeight = lineAscHeight;
    if (lineXHeight) lineObj.xHeight = lineXHeight;

    // If neither ascHeight nor xHeight are known, total height is assumed to represent ascHeight, on the grounds that it is better than nothing.
    if (!lineAscHeight && !lineXHeight && lineAllHeight && Number.isFinite(lineAllHeight)) lineObj.ascHeight = lineAllHeight;

    // Replace all dash characters with a hyphen, en-dash or em-dash, depending on their width.
    // OCR engines commonly use the wrong type of dash. This is especially problematic during font optimization,
    // as it can result (for example) in a hyphen being scaled to be closer to an en-dash if the latter is more common.
    for (let j = 0; j < lineObj.words.length; j++) {
      const wordObj = lineObj.words[j];

      // This condition should not occur, however has in the past due to parsing bugs.  Skipping to avoid entire program crashing if this occurs.
      if (wordObj.chars && wordObj.chars.length !== wordObj.text.length) continue;

      const letterArr = wordObj.text.split('');
      const charObjArr = wordObj.chars;

      // This step requires character-level metrics.
      if (!charObjArr || !wordObj.line.xHeight) continue;

      // In some documents Abbyy consistently uses "¬" rather than "-" for hyphenated words at the the end of lines, so this symbol is included.
      for (let k = 0; k < letterArr.length; k++) {
        if (['-', '–', '—', '¬'].includes(letterArr[k]) && letterArr.length > 1) {
          const charWidth = charObjArr[k].bbox[2] - charObjArr[k].bbox[0];
          const charWidthNorm = charWidth / wordObj.line.xHeight;
          if (charWidthNorm > 1.5) {
            letterArr[k] = '—';
            if (charObjArr) charObjArr[k].text = '—';
          } else if (charWidthNorm > 0.9) {
            letterArr[k] = '–';
            if (charObjArr) charObjArr[k].text = '–';
          } else {
            letterArr[k] = '-';
            if (charObjArr) charObjArr[k].text = '-';
          }
        }
      }
      wordObj.text = letterArr.join('');
    }

    for (let j = 0; j < lineObj.words.length; j++) {
      const wordObj = lineObj.words[j];
      const wordFontFamily = wordObj.font || 'Default';

      // This condition should not occur, however has in the past due to parsing bugs.  Skipping to avoid entire program crashing if this occurs.
      if (wordObj.chars && wordObj.chars.length !== wordObj.text.length) continue;

      // Do not include superscripts, dropcaps, and low-confidence words in statistics for font optimization.
      if (wordObj.conf < 80) continue;
      /** @type {Object.<string, FontMetricsRawFamily>} */
      const fontMetricsRawLine = {};

      if (wordObj.chars) {
        for (let k = 0; k < wordObj.chars.length; k++) {
          const charObj = wordObj.chars[k];

          const charHeight = charObj.bbox[3] - charObj.bbox[1];
          const charWidth = charObj.bbox[2] - charObj.bbox[0];

          // Numbers are normalized as a proportion of ascHeight, everything else is normalized as a percentage of x-height.
          // This is because x-sized characters are more common in text, however numbers are often in "lines" with only numbers,
          // so do not have any x-sized characters to compare to.
          const charNorm = /\d/.test(charObj.text) ? lineObj.ascHeight : lineObj.xHeight;

          if (!charNorm) continue;

          // Multiple characters within a single <ocrx_cinfo> tag have been observed from Tesseract (even when set to char-level output).
          // May cause future issues as this code assumes one character per <ocrx_cinfo> tag.
          const charUnicode = String(charObj.text.charCodeAt(0));

          if (!fontMetricsRawLine[wordFontFamily]) {
            fontMetricsRawLine[wordFontFamily] = new FontMetricsRawFamily();
          }

          if (!fontMetricsRawLine[wordFontFamily][wordObj.style].width[charUnicode]) {
            fontMetricsRawLine[wordFontFamily][wordObj.style].width[charUnicode] = [];
            fontMetricsRawLine[wordFontFamily][wordObj.style].height[charUnicode] = [];
          }

          fontMetricsRawLine[wordFontFamily][wordObj.style].width[charUnicode].push(charWidth / charNorm);
          fontMetricsRawLine[wordFontFamily][wordObj.style].height[charUnicode].push(charHeight / charNorm);
          fontMetricsRawLine[wordFontFamily][wordObj.style].obs += 1;

          if (k + 1 < wordObj.chars.length) {
            const charObjNext = wordObj.chars[k + 1];
            const trailingSpace = charObjNext.bbox[0] - charObj.bbox[2];
            const charWidthNext = charObjNext.bbox[2] - charObjNext.bbox[0];

            // Only record space between characters when text is moving forward
            // This *should* always be true, however there are some fringe cases where this assumption does not hold,
            // such as Tesseract identifying the same character twice.
            if (trailingSpace + charWidthNext > 0) {
              const bigramUnicode = `${charUnicode},${wordObj.chars[k + 1].text.charCodeAt(0)}`;

              if (!fontMetricsRawLine[wordFontFamily][wordObj.style].kerning[bigramUnicode]) {
                fontMetricsRawLine[wordFontFamily][wordObj.style].kerning[bigramUnicode] = [];
                fontMetricsRawLine[wordFontFamily][wordObj.style].kerning2[bigramUnicode] = [];
              }
              fontMetricsRawLine[wordFontFamily][wordObj.style].kerning[bigramUnicode].push(trailingSpace / charNorm);
              fontMetricsRawLine[wordFontFamily][wordObj.style].kerning2[bigramUnicode].push((trailingSpace + charWidthNext) / charNorm);
            }
          }
        }
      }

      for (const [family, obj] of Object.entries(fontMetricsRawLine)) {
        for (const [style, obj2] of Object.entries(obj)) {
          if (Object.keys(obj2.width).length === 0) continue;
          if (!fontMetricsRawPage[family]) {
            fontMetricsRawPage[family] = new FontMetricsRawFamily();
          }
        }
      }

      for (const [family, obj] of Object.entries(fontMetricsRawPage)) {
        for (const [style, obj2] of Object.entries(obj)) {
          unionFontMetricsFont(fontMetricsRawPage?.[family]?.[style], fontMetricsRawLine?.[family]?.[style]);
        }
      }
    }
  }

  return {
    pageObj, fontMetricsObj: fontMetricsRawPage, layoutBoxes, warn,
  };
}
