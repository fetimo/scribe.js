import ocr from '../objects/ocrObjects.js';

import { quantile, mean50, unescapeXml } from '../miscUtils.js';

import { pass2 } from './convertPageShared.js';

import { determineSansSerif } from '../fontStatistics.js';

// If enabled, raw strings are saved in OCR objects for debugging purposes.
const debugMode = true;

/**
 * @param {Object} params
 * @param {string} params.ocrStr
 * @param {number} params.n
 * @param {?dims} params.pageDims
 * @param {number} params.rotateAngle - The angle that the input image is rotated prior to recognition.
 *    This is used to transform OCR coordinates back to the original coordinate space after recognizing a rotated intermediate image.
 * @param {boolean} params.keepItalic - If true, italic tags (`<em>`) are honored.  This is false by default,
 *    as vanilla Tesseract does not recognize italic text in a way that is reliable.
 *    This is fixed for Legacy recognition in the included custom build of Tesseract.
 */
export async function convertPageHocr({
  ocrStr, n, pageDims = null, rotateAngle = 0, keepItalic = false,
}) {
  rotateAngle = rotateAngle || 0;

  let currentLang = 'eng';

  const angleRisePage = [];
  const lineLeft = [];
  const lineTop = [];

  // If page dimensions are not provided as an argument, we assume that the entire image is being recognized
  // (so the width/height of the image bounding box is the same as the width/height of the image).
  if (!pageDims) {
    const pageElement = ocrStr.match(/<div class=["']ocr_page["'][^>]+/i);
    if (pageElement != null) {
      const pageDimsMatch = pageElement[0].match(/bbox \d+ \d+ (\d+) (\d+)/i);
      if (pageDimsMatch != null) {
        pageDims = { height: parseInt(pageDimsMatch[2]), width: parseInt(pageDimsMatch[1]) };
      }
    }
  }

  const pageObj = new ocr.OcrPage(n, pageDims);

  // Test whether character-level data (class="ocrx_cinfo" in Tesseract) is present.
  const charMode = !!/ocrx_cinfo/.test(ocrStr);

  // Test whether cuts are present.
  // This will be the case for users re-importing HOCR generated by the site.
  // const cutsMode = /\<span[^\>]*cuts/i.test(ocrStr) ? true : false;

  // The JavaScript regex engine does not support matching start/end tags (some other engines do), so the end of words and lines are detected
  // through a hard-coded number of </span> end tags.  The only difference charMode should make on the expressions below is the number of
  // consecutive </span> tags required.
  let lineRegex = /<span class=["']ocr_line[\s\S]+?(?:<\/span>\s*){2}/ig;
  if (charMode) {
    lineRegex = /<span class=["']ocr_line[\s\S]+?(?:<\/span>\s*)(?:<\/em>\s*)?(?:<\/span>\s*){2}/ig;
  }

  const wordRegexCharLevel = /<span class=["']ocrx_word[\s\S]+?(?:<\/span>\s*)(?:<\/em>\s*)?(?:<\/span>\s*){1}/ig;
  const wordRegex = /<span class=["']ocrx_word[\s\S]+?(?:<\/span>\s*)/ig;

  const charRegex = /<span class=["']ocrx_cinfo["'] title='([^'"]+)["']>([^<]*)<\/span>/ig;

  // Remove all bold/italics tags.  These complicate the syntax and are unfortunately virtually always wrong anyway (coming from Tesseract).
  ocrStr = ocrStr.replaceAll(/<\/?strong>/ig, '');

  // The custom built-in Tesseract build should reliably identify italics (for Legacy only)
  if (!keepItalic) {
    ocrStr = ocrStr.replaceAll(/<\/?em>/ig, '');
  }

  // Delete namespace to simplify xpath
  ocrStr = ocrStr.replace(/<html[^>]*>/i, '<html>');

  // Replace various classes with "ocr_line" class for simplicity
  // At least in Tesseract, these elements are not identified accurately or consistently enough to warrent different treatment.
  ocrStr = ocrStr.replace(/(class=')ocr_caption/ig, '$1ocr_line');
  ocrStr = ocrStr.replace(/(class=')ocr_textfloat/ig, '$1ocr_line');
  ocrStr = ocrStr.replace(/(class=')ocr_header/ig, '$1ocr_line');

  /**
     * @param {string} match
     */
  function convertLine(match) {
    const titleStrLine = match.match(/title=['"]([^'"]+)/)?.[1];
    if (!titleStrLine) return '';

    const linebox1 = [...titleStrLine.matchAll(/bbox(?:es)?(\s+\d+)(\s+\d+)?(\s+\d+)?(\s+\d+)?/g)][0].slice(1, 5).map((x) => parseInt(x));

    const linebox = {
      left: linebox1[0], top: linebox1[1], right: linebox1[2], bottom: linebox1[3],
    };

    // The baseline can be missing in the case of vertical text (textangle present instead)
    const baselineMatch = [...titleStrLine.matchAll(/baseline(\s+[\d.-]+)(\s+[\d.-]+)/g)][0];

    if (!baselineMatch) return '';

    const baseline = baselineMatch.slice(1, 5).map((x) => parseFloat(x));

    // Only calculate baselines from lines 200px+.
    // This avoids short "lines" (e.g. page numbers) that often report wild values.
    if ((linebox.right - linebox.left) >= 200) {
      angleRisePage.push(baseline[0]);
      lineLeft.push(linebox.left);
      lineTop.push(linebox.top);
    }

    // Line font size metrics as reported by Tesseract.
    // As these are frequently not correct (as Tesseract calculates them before character recognition),
    // so they may be replaced later by versions we calculate.
    const lineAllHeightTessStr = parseFloat(titleStrLine.match(/x_size\s+([\d.-]+)/)?.[1] || '15');
    const lineAscHeightTessStr = parseFloat(titleStrLine.match(/x_ascenders\s+([\d.-]+)/)?.[1] || '0');
    const lineDescHeightTessStr = parseFloat(titleStrLine.match(/x_descenders\s+([\d.-]+)/)?.[1] || '0');

    const lineAscHeightTess = lineAllHeightTessStr - lineDescHeightTessStr;

    // When Scribe exports lines with `null` `xHeight` values to HOCR, `x_ascenders` is omitted.
    let lineXHeightTess = null;
    if (lineAscHeightTessStr > 0) {
      lineXHeightTess = lineAllHeightTessStr - lineDescHeightTessStr - lineAscHeightTessStr;
    }

    const lineObj = new ocr.OcrLine(pageObj, linebox, baseline, lineAscHeightTess, lineXHeightTess);

    if (debugMode) lineObj.raw = match;

    const heightSmallCapsLine = [];

    /**
     * @param {string} match
     */
    function convertWordCharLevel(match) {
      let text = '';

      const titleStrWord = match.match(/title=['"]([^'"]+)/)?.[1];
      const confMatch = titleStrWord.match(/(?:;|\s)x_wconf\s+(\d+)/);
      let wordConf = 0;
      if (confMatch != null) {
        wordConf = parseInt(confMatch[1]);
      }

      const italic = /<\/em>\s*<\/span>/.test(match);

      const wordID = match.match(/id=['"]([^'"]*)['"]/i)?.[1];

      const wordLangRaw = match.match(/lang=['"]([^'"]*)['"]/i)?.[1];

      const fontName = match.match(/^[^>]+?x_font\s*([\w-]+)/)?.[1];

      const fontFamily = determineSansSerif(fontName);

      const it = match.matchAll(charRegex);
      let letterArr = [...it];

      // Unlike Abbyy, which generally identifies small caps as lowercase letters (and identifies small cap text explicitly as a formatting property),
      // Tesseract (at least the Legacy model) reports them as upper-case letters.
      const wordStr = letterArr.map((x) => x[2]).join('');
      let smallCaps = false;
      let smallCapsTitle = false;
      let minLetterIndex = 0;
      if (!/[a-z]/.test(wordStr) && /[A-Z].?[A-Z]/.test(wordStr)) {
        // Filter to only include letters
        const filterArr = wordStr.split('').map((x) => /[a-z]/i.test(x));
        const letterArrSub = letterArr.filter((x, y) => filterArr[y]);

        // Index of first letter (the only capital letter for title case)
        minLetterIndex = Math.min(...[...Array(filterArr.length).keys()].filter((x, y) => filterArr[y]));

        const wordBboxesTop = letterArrSub.map((x) => parseInt(x[1].match(/\d+ (\d+)/)[1]));
        const wordBboxesBottom = letterArrSub.map((x) => parseInt(x[1].match(/\d+ \d+ \d+ (\d+)/)[1]));

        // Check for small caps words in title case (first letter larger than all following letters)
        if (Math.min(...letterArrSub.map((x) => x[1].match(/\d+ (\d+)/)[1]).map((x) => Math.sign((x - wordBboxesBottom[0]) + ((wordBboxesBottom[0] - wordBboxesTop[0]) * 0.90))).slice(1)) === 1) {
          smallCaps = true;
          smallCapsTitle = true;
          for (let i = 1; i < wordBboxesTop.length; i++) {
            heightSmallCapsLine.push(wordBboxesBottom[i] - wordBboxesTop[i]);
          }
          // Check for small caps words in lowercase (all letters the same size, which is around the same size as small caps in previous words in line)
          // The 10% margin accounts for random variation in general, however is also important since rounded letters (e.g. "O") are taller but
          // less common, so will almost always exceed the median.
        } else {
          const letterHeightArr = wordBboxesBottom.map((x, y) => x - wordBboxesTop[y]);
          const heightSmallCapsLineMedian = quantile(heightSmallCapsLine, 0.5);
          if (heightSmallCapsLineMedian && letterHeightArr.filter((x) => x > heightSmallCapsLineMedian * 1.1).length === 0) {
            smallCaps = true;
          }
        }
      }

      const bboxes = letterArr.map((x) => x[1].match(/(\d+) (\d+) (\d+) (\d+)/).slice(1, 5).map((y) => parseInt(y)));

      // Adjust box such that top/bottom approximate those coordinates at the leftmost point
      const lineboxAdj = { ...linebox };

      if (baseline[0] < 0) {
        lineboxAdj.top -= (lineboxAdj.right - lineboxAdj.left) * baseline[0];
      } else {
        lineboxAdj.bottom -= (lineboxAdj.right - lineboxAdj.left) * baseline[0];
      }

      let wordLang = wordLangRaw || currentLang;
      if (['chi_sim', 'chi_tra'].includes(wordLang)) {
        let hanChars = 0;
        let latinChars = 0;
        for (let j = 0; j < letterArr.length; j++) {
          const contentStrLetter = letterArr[j][2];
          if (/\p{Script=Han}/u.test(contentStrLetter)) hanChars++;
          if (/\p{Script=Latin}/u.test(contentStrLetter)) latinChars++;
        }
        if (hanChars === 0) {
          // Do not let languages be switched for a word that contains 0 Han characters.
          if (!['chi_sim', 'chi_tra'].includes(currentLang)) {
            wordLang = currentLang;
          // Do not let language be Chinese for any word that contains no Han characters and >0 non-Chinese characters.
          // TODO: Assign the appropriate Latin language (not necessarily English).
          } else if (latinChars > 0) {
            wordLang = 'eng';
          }
        }
      }

      // Tesseract does not split superscript footnote references into separate words, so that happens here.
      // This should only happen for Latin languages.
      let letterArrSuper = [];
      if (!['chi_sim', 'chi_tra'].includes(wordLang)) {
        // if (/^\W?[a-z]/i.test(wordStr) && /\d$/i.test(wordStr)) {
        if (/\d$/i.test(wordStr)) {
          const numsN = wordStr.match(/\d+$/)[0].length;

          const expectedBaseline = (bboxes[0][0] + (bboxes[bboxes.length - 1][2] - bboxes[0][0]) / 2 - lineboxAdj.left) * baseline[0] + baseline[1] + lineboxAdj.bottom;
          const lineAscHeight = expectedBaseline - lineboxAdj.top;

          let baseN = 0;
          for (let i = bboxes.length - 1; i >= 0; i--) {
            if (bboxes[i][3] < expectedBaseline - lineAscHeight / 4) {
              baseN++;
            } else {
              break;
            }
          }

          const superN = Math.min(numsN, baseN);

          if (superN > 0) {
            letterArrSuper = letterArr.slice(letterArr.length - superN, letterArr.length);
            letterArr = letterArr.slice(0, letterArr.length - superN);
          }
        }
      }

      const charObjArr = [];

      for (let j = 0; j < letterArr.length; j++) {
        let contentStrLetter = letterArr[j][2];

        // If word is small caps, convert letters to lower case.
        if (smallCaps && (!smallCapsTitle || j > minLetterIndex)) {
          contentStrLetter = contentStrLetter.toLowerCase();
        }

        // Handle characters escaped in XML
        contentStrLetter = unescapeXml(contentStrLetter);

        const bbox = {
          left: bboxes[j][0], top: bboxes[j][1], right: bboxes[j][2], bottom: bboxes[j][3],
        };

        // For Chinese, every "character" in the .hocr should be its own word.
        // Tesseract LSTM already does this, however Tesseract Legacy combines entire lines into the same "word",
        // which makes good alignment impossible.
        if (wordLang === 'chi_sim') {
          const wordObj = new ocr.OcrWord(lineObj, contentStrLetter, bbox, `${wordID}_${j}`);
          wordObj.conf = wordConf;
          wordObj.lang = wordLang;

          lineObj.words.push(wordObj);
        } else {
          const charObj = new ocr.OcrChar(contentStrLetter, bbox);
          charObjArr.push(charObj);

          text += contentStrLetter;
        }
      }

      if (wordLang === 'chi_sim') return '';

      text = text ?? '';
      text = text.trim();

      if (letterArrSuper.length > 0) {
        // Calculate new bounding boxes

        if (text) {
          const bboxesCore = letterArr.map((x) => x[1].match(/(\d+) (\d+) (\d+) (\d+)/).slice(1, 5));

          const wordBoxCore = {
            left: Math.min(...bboxesCore.map((x) => x[0])),
            top: Math.min(...bboxesCore.map((x) => x[1])),
            right: Math.max(...bboxesCore.map((x) => x[2])),
            bottom: Math.max(...bboxesCore.map((x) => x[3])),
          };

          const wordObjCore = new ocr.OcrWord(lineObj, text, wordBoxCore, wordID);
          wordObjCore.chars = charObjArr;
          wordObjCore.lang = wordLang;

          if (debugMode) wordObjCore.raw = match;

          if (smallCaps || italic || fontFamily !== 'Default') {
            if (smallCaps) {
              wordObjCore.style = 'small-caps';
            } else if (italic) {
              wordObjCore.style = 'italic';
            }
            if (fontFamily !== 'Default') {
              wordObjCore.font = fontFamily;
            }
          }

          wordObjCore.conf = wordConf;

          lineObj.words.push(wordObjCore);
        }

        const bboxesSuper = letterArrSuper.map((x) => x[1].match(/(\d+) (\d+) (\d+) (\d+)/)?.slice(1, 5).map((y) => parseInt(y)));

        const wordBoxSuper = {
          left: Math.min(...bboxesSuper.map((x) => x[0])),
          top: Math.min(...bboxesSuper.map((x) => x[1])),
          right: Math.max(...bboxesSuper.map((x) => x[2])),
          bottom: Math.max(...bboxesSuper.map((x) => x[3])),
        };

        const textSuper = letterArrSuper.map((x) => x[2]).join('');

        const wordObjSup = new ocr.OcrWord(lineObj, textSuper, wordBoxSuper, `${wordID}a`);
        wordObjSup.lang = wordLang;

        if (debugMode) wordObjSup.raw = match;

        wordObjSup.conf = wordConf;

        wordObjSup.sup = true;

        lineObj.words.push(wordObjSup);

        return '';
      }
      if (text === '') return ('');

      const bboxesCore = letterArr.map((x) => x[1].match(/(\d+) (\d+) (\d+) (\d+)/)?.slice(1, 5).map((y) => parseInt(y)));

      const wordBoxCore = {
        left: Math.min(...bboxesCore.map((x) => x[0])),
        top: Math.min(...bboxesCore.map((x) => x[1])),
        right: Math.max(...bboxesCore.map((x) => x[2])),
        bottom: Math.max(...bboxesCore.map((x) => x[3])),
      };

      const wordObj = new ocr.OcrWord(lineObj, text, wordBoxCore, `${wordID}a`);
      wordObj.lang = wordLang;

      wordObj.chars = charObjArr;

      if (debugMode) wordObj.raw = match;

      if (smallCaps || italic || fontFamily !== 'Default') {
        if (smallCaps) {
          wordObj.style = 'small-caps';
        } else if (italic) {
          wordObj.style = 'italic';
        }
        if (fontFamily !== 'Default') {
          wordObj.font = fontFamily;
        }
      }

      wordObj.conf = wordConf;

      lineObj.words.push(wordObj);

      return '';
    }

    /**
       * @param {string} match
       */
    function convertWord(match) {
      const wordID = match.match(/id=['"]([^'"]*)['"]/i)?.[1];

      const wordSup = /<sup>/i.test(match);
      const wordDropCap = /<span class=['"]ocr_dropcap['"]>/i.test(match);

      let wordText;
      if (wordSup) {
        wordText = match.replace(/\s*<sup>/i, '').replace(/<\/sup>\s*/i, '').match(/>([^>]*)</)?.[1];
      } else if (wordDropCap) {
        wordText = match.replace(/\s*<span class=['"]ocr_dropcap['"]>/i, '').match(/>([^>]*)</)?.[1];
      } else {
        wordText = match.match(/>([^>]*)</)?.[1];
      }

      wordText = unescapeXml(wordText);

      if (!wordText) {
        return '';
      }

      const titleStrWord = match.match(/title=['"]([^'"]+)/)?.[1];

      const wordLang = match.match(/lang=['"]([^'"]*)['"]/i)?.[1] || currentLang;

      if (!titleStrWord) {
        console.log(`Unable to process word, skipping: ${match}`);
        return '';
      }

      const wordBox1 = [...titleStrWord.matchAll(/bbox(?:es)?(\s+[\d-]+)(\s+[\d-]+)?(\s+[\d-]+)?(\s+[\d-]+)?/g)][0].slice(1, 5).map((x) => parseInt(x));

      const wordBox = {
        left: wordBox1[0],
        top: wordBox1[1],
        right: wordBox1[2],
        bottom: wordBox1[3],
      };

      const fontName = match.match(/^[^>]+?x_font\s*([\w-]+)/)?.[1];

      const fontFamily = determineSansSerif(fontName);

      const styleStr = match.match(/style=['"]([^'"]+)/)?.[1];

      let fontStyle = 'normal';
      if (styleStr && /italic/i.test(styleStr)) {
        fontStyle = 'italic';
      } else if (styleStr && /small-caps/i.test(styleStr)) {
        fontStyle = 'small-caps';
      }

      const confMatch = titleStrWord.match(/(?:;|\s)x_wconf\s+(\d+)/)?.[1] || '0';
      const wordConf = parseInt(confMatch) || 0;

      const wordObj = new ocr.OcrWord(lineObj, wordText, wordBox, `${wordID}a`);
      wordObj.lang = wordLang;

      wordObj.style = fontStyle;
      if (fontFamily !== 'Default') {
        wordObj.font = fontFamily;
      }

      wordObj.conf = wordConf;

      lineObj.words.push(wordObj);

      return '';
    }

    if (charMode) {
      match = match.replaceAll(wordRegexCharLevel, convertWordCharLevel);
    } else {
      match = match.replaceAll(wordRegex, convertWord);
    }

    // Re-calculate line bounding box and adjust baseline.
    // Hocr data from Tesseract can omit certain characters when calculating line-level bounding boxes.
    // Therefore, the bounding box is recalculated using `ocr.calcLineBbox` (which is used by the editor),
    // and any difference in the bottom of the bounding box is added to the `baseline` property,
    // which is assumed to be correct coming out of Tesseract.
    const lineboxBottomOrig = lineObj.bbox.bottom;
    ocr.calcLineBbox(lineObj);
    lineObj.baseline[1] += (lineboxBottomOrig - lineObj.bbox.bottom);

    pageObj.lines.push(lineObj);

    return '';
  }

  /**
     * @param {string} match
     */
  const convertPar = (match) => {
    const parLang = match.match(/^.+?lang=['"]([^'"]*)['"]/i)?.[1];
    if (parLang) currentLang = parLang;
    match.replaceAll(lineRegex, convertLine);
    return '';
  };

  ocrStr = ocrStr.replaceAll(/<p class=["']ocr_par[\s\S]+?(?:<\/p>\s*)/ig, convertPar);

  ocrStr = ocrStr.replaceAll(lineRegex, convertLine);

  const angleRiseMedian = mean50(angleRisePage) || 0;

  const lineLeftAdj = [];
  for (let i = 0; i < lineLeft.length; i++) {
    lineLeftAdj.push(lineLeft[i] + angleRiseMedian * lineTop[i]);
  }

  pageObj.angle = Math.abs(rotateAngle) > 0.05 ? rotateAngle : Math.asin(angleRiseMedian) * (180 / Math.PI);

  const sinAngle = Math.sin(pageObj.angle * (Math.PI / 180));
  const shiftX = sinAngle * (pageDims.height * 0.5) * -1 || 0;

  let leftOut = quantile(lineLeft, 0.2) - shiftX;
  const leftAdjOut = quantile(lineLeftAdj, 0.2) - shiftX - leftOut;

  // With <5 lines either a left margin does not exist (e.g. a photo or title page) or cannot be reliably determined
  if (lineLeft.length < 5) {
    leftOut = null;
  }

  pageObj.left = leftOut;
  pageObj.leftAdj = leftAdjOut;

  // Transform bounding boxes if rotation is specified.
  // This option is used when an image is rotated before it is sent to Tesseract,
  // however the HOCR needs to be applied to the original image.
  if (Math.abs(rotateAngle) > 0.05) {
    for (let i = 0; i < pageObj.lines.length; i++) {
      ocr.rotateLine(pageObj.lines[i], rotateAngle);
    }
  }

  const warn = { char: charMode ? '' : 'char_warning' };

  pass2(pageObj);

  return { pageObj, layoutBoxes: {}, warn };
}
